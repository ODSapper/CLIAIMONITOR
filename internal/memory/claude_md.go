package memory

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"
)

// ClaudeMDUpdater handles updating CLAUDE.md with recon intelligence
type ClaudeMDUpdater struct {
	repoPath string
	db       ReconRepository
}

// NewClaudeMDUpdater creates a new CLAUDE.md updater
func NewClaudeMDUpdater(repoPath string, db ReconRepository) *ClaudeMDUpdater {
	return &ClaudeMDUpdater{
		repoPath: repoPath,
		db:       db,
	}
}

// Update updates the CLAUDE.md file with latest recon intelligence
func (u *ClaudeMDUpdater) Update(ctx context.Context, envID string) error {
	claudeMDPath := filepath.Join(u.repoPath, "CLAUDE.md")

	// Read existing content
	content, err := os.ReadFile(claudeMDPath)
	if err != nil {
		if os.IsNotExist(err) {
			// Create new CLAUDE.md
			content = []byte("# CLAUDE.md\n\nProject context for Claude Code.\n\n")
		} else {
			return fmt.Errorf("failed to read CLAUDE.md: %w", err)
		}
	}

	// Get critical and high severity findings
	criticalFindings, err := u.db.GetFindings(ctx, FindingFilter{
		EnvID:    envID,
		Severity: "critical",
		Status:   "open",
		Limit:    15,
	})
	if err != nil {
		return fmt.Errorf("failed to get critical findings: %w", err)
	}

	highFindings, err := u.db.GetFindings(ctx, FindingFilter{
		EnvID:    envID,
		Severity: "high",
		Status:   "open",
		Limit:    15,
	})
	if err != nil {
		return fmt.Errorf("failed to get high findings: %w", err)
	}

	// Build recon section
	reconSection := u.buildReconSection(criticalFindings, highFindings)

	// Update content
	updatedContent := u.updateContent(string(content), reconSection)

	// Write back
	if err := os.WriteFile(claudeMDPath, []byte(updatedContent), 0644); err != nil {
		return fmt.Errorf("failed to write CLAUDE.md: %w", err)
	}

	fmt.Printf("[CLAUDE.md] Updated with %d critical and %d high priority findings\n",
		len(criticalFindings), len(highFindings))

	return nil
}

// buildReconSection creates the reconnaissance intelligence section
func (u *ClaudeMDUpdater) buildReconSection(critical, high []*ReconFinding) string {
	var sb strings.Builder

	sb.WriteString("## Recon Intelligence\n\n")
	sb.WriteString("> Auto-generated by Snake Agent reconnaissance. Last updated: ")
	sb.WriteString(time.Now().Format("2006-01-02 15:04:05"))
	sb.WriteString("\n\n")

	totalOpen := len(critical) + len(high)
	if totalOpen == 0 {
		sb.WriteString("**Status**: All clear - no critical or high severity findings.\n\n")
		sb.WriteString("For comprehensive findings across all severities, see:\n")
		sb.WriteString("- [Security Vulnerabilities](docs/recon/vulnerabilities.md)\n")
		sb.WriteString("- [Architecture Findings](docs/recon/architecture.md)\n")
		sb.WriteString("- [Dependency Health](docs/recon/dependencies.md)\n")
		sb.WriteString("- [Infrastructure Status](docs/recon/infrastructure.md)\n\n")
		return sb.String()
	}

	sb.WriteString(fmt.Sprintf("**Alert**: %d open issues require attention ", totalOpen))
	sb.WriteString(fmt.Sprintf("(%d critical, %d high)\n\n", len(critical), len(high)))

	// Critical findings
	if len(critical) > 0 {
		sb.WriteString("### Critical Findings\n\n")
		sb.WriteString("> These issues pose immediate risk and should be addressed urgently.\n\n")

		for i, finding := range critical {
			if i >= 10 { // Limit to top 10 in hot layer
				remaining := len(critical) - 10
				sb.WriteString(fmt.Sprintf("\n*...and %d more critical findings. See [details](docs/recon/vulnerabilities.md)*\n", remaining))
				break
			}

			sb.WriteString(fmt.Sprintf("#### %d. %s\n\n", i+1, finding.Title))
			sb.WriteString(fmt.Sprintf("- **ID**: `%s`\n", finding.ID))
			sb.WriteString(fmt.Sprintf("- **Type**: %s\n", finding.FindingType))

			if finding.Location != "" {
				sb.WriteString(fmt.Sprintf("- **Location**: `%s`\n", finding.Location))
			}

			sb.WriteString(fmt.Sprintf("- **Discovered**: %s\n", finding.DiscoveredAt.Format("2006-01-02")))
			sb.WriteString("\n")

			// Description (truncated)
			desc := finding.Description
			if len(desc) > 200 {
				desc = desc[:197] + "..."
			}
			sb.WriteString(fmt.Sprintf("%s\n\n", desc))

			// Recommendation (truncated)
			if finding.Recommendation != "" {
				rec := finding.Recommendation
				if len(rec) > 150 {
					rec = rec[:147] + "..."
				}
				sb.WriteString(fmt.Sprintf("**Action Required**: %s\n\n", rec))
			}
		}
	}

	// High severity findings (summary only)
	if len(high) > 0 {
		sb.WriteString("### High Priority Findings\n\n")
		sb.WriteString("> These issues should be scheduled for resolution soon.\n\n")

		for i, finding := range high {
			if i >= 10 { // Limit to top 10 in hot layer
				remaining := len(high) - 10
				sb.WriteString(fmt.Sprintf("\n*...and %d more high priority findings. See [details](docs/recon/vulnerabilities.md)*\n", remaining))
				break
			}

			sb.WriteString(fmt.Sprintf("- **%s** [`%s`]\n", finding.Title, finding.ID))
			sb.WriteString(fmt.Sprintf("  - %s | %s", finding.FindingType, finding.Location))
			if finding.Location == "" {
				sb.WriteString("No specific location")
			}
			sb.WriteString("\n")
		}
		sb.WriteString("\n")
	}

	// Footer
	sb.WriteString("### Full Reports\n\n")
	sb.WriteString("For complete findings with full descriptions and resolution tracking:\n\n")
	sb.WriteString("- [Security Vulnerabilities](docs/recon/vulnerabilities.md) - All security-related findings\n")
	sb.WriteString("- [Architecture Findings](docs/recon/architecture.md) - Design and structure issues\n")
	sb.WriteString("- [Dependency Health](docs/recon/dependencies.md) - Library and package concerns\n")
	sb.WriteString("- [Infrastructure Status](docs/recon/infrastructure.md) - Process and deployment issues\n\n")

	return sb.String()
}

// updateContent updates the CLAUDE.md content with the recon section
func (u *ClaudeMDUpdater) updateContent(content, reconSection string) string {
	startMarker := "## Recon Intelligence"

	// Find existing section
	startIdx := strings.Index(content, startMarker)
	if startIdx == -1 {
		// Section doesn't exist, add it near the top (after first heading)
		lines := strings.Split(content, "\n")
		insertIdx := 0

		// Find first blank line after initial heading
		foundHeading := false
		for i, line := range lines {
			if strings.HasPrefix(line, "#") {
				foundHeading = true
			} else if foundHeading && strings.TrimSpace(line) == "" {
				insertIdx = i + 1
				break
			}
		}

		if insertIdx == 0 {
			// Just append at end
			return content + "\n" + reconSection
		}

		// Insert after the found position
		before := strings.Join(lines[:insertIdx], "\n")
		after := strings.Join(lines[insertIdx:], "\n")
		return before + "\n" + reconSection + after
	}

	// Find end of existing section (next heading at same or higher level)
	endIdx := len(content)
	searchStart := startIdx + len(startMarker)

	// Look for next section (## or #)
	restContent := content[searchStart:]
	for _, marker := range []string{"\n## ", "\n# "} {
		if idx := strings.Index(restContent, marker); idx != -1 {
			candidateIdx := searchStart + idx
			if candidateIdx < endIdx {
				endIdx = candidateIdx
			}
		}
	}

	// Replace the section
	before := content[:startIdx]
	after := ""
	if endIdx < len(content) {
		after = content[endIdx:]
	}

	return before + reconSection + after
}

// Remove removes the Recon Intelligence section from CLAUDE.md
func (u *ClaudeMDUpdater) Remove(ctx context.Context) error {
	claudeMDPath := filepath.Join(u.repoPath, "CLAUDE.md")

	content, err := os.ReadFile(claudeMDPath)
	if err != nil {
		if os.IsNotExist(err) {
			return nil // Nothing to remove
		}
		return fmt.Errorf("failed to read CLAUDE.md: %w", err)
	}

	startMarker := "## Recon Intelligence"
	startIdx := strings.Index(string(content), startMarker)
	if startIdx == -1 {
		return nil // Section doesn't exist
	}

	// Find end of section
	endIdx := len(content)
	searchStart := startIdx + len(startMarker)
	restContent := string(content[searchStart:])

	for _, marker := range []string{"\n## ", "\n# "} {
		if idx := strings.Index(restContent, marker); idx != -1 {
			candidateIdx := searchStart + idx
			if candidateIdx < endIdx {
				endIdx = candidateIdx
			}
		}
	}

	// Remove the section
	before := string(content[:startIdx])
	after := ""
	if endIdx < len(content) {
		after = string(content[endIdx:])
	}

	updatedContent := before + after

	if err := os.WriteFile(claudeMDPath, []byte(updatedContent), 0644); err != nil {
		return fmt.Errorf("failed to write CLAUDE.md: %w", err)
	}

	fmt.Println("[CLAUDE.md] Removed Recon Intelligence section")
	return nil
}

// HasReconSection checks if CLAUDE.md has a recon intelligence section
func (u *ClaudeMDUpdater) HasReconSection() (bool, error) {
	claudeMDPath := filepath.Join(u.repoPath, "CLAUDE.md")

	content, err := os.ReadFile(claudeMDPath)
	if err != nil {
		if os.IsNotExist(err) {
			return false, nil
		}
		return false, fmt.Errorf("failed to read CLAUDE.md: %w", err)
	}

	return strings.Contains(string(content), "## Recon Intelligence"), nil
}
